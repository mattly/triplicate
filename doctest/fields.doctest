    >> $:.unshift File.dirname(__FILE__)
    doctest_require: 'doctest_helper'
	doctest_require: '../lib/triplicate'
	>> Triplicate
	=> Triplicate

# Triplicate Fields

Triplicate field definitions don't define getters and setters on its form objects, but rather grant or deny access to read or write to certain fields. They can interpret fields as certain class types, and confirm certain data patters on write.
	
	doctest: basic read and write access
	>> class Document
			include Triplicate
			field :title
			end
	>> doc = Document.new
	>> doc[:title]
	=> nil
	>> doc[:title] = "Hello There"
	>> doc.document
	=> {"title" => "Hello There"}
	>> doc[:title]
	=> "Hello There"
	
	>> doc[:random_field]
	=> nil
	>> doc[:random_field] = "hahahaha"
	>> doc.document
	=> {"title" => "Hello There"}
	
Note that because we haven't allowed for random read access, we couldn't read the `random_field` even if there was data in it (more on that later):
	
	>> doc.document.update({'random_field' => 'hidden'})
	>> doc[:random_field]
	=> nil
	
## Default Values

You can define default values for the document:
	
	doctest: field definition with default
	>> class Document
			include Triplicate
			field :author, :default => 'anonymous'
			end
	>> doc = Document.new
	>> doc[:author]
	=> "anonymous"

Note that this does not actually set the value:

	>> doc.document['author']
	=> nil

But only provides a fallback for a missing value:

	>> doc = Document.new('author' => 'mattly')
	>> doc[:author]
	=> "mattly"

## Coercion

While a JSON-like storage system will typically allow you to store whatever kind of data in whatever field you want, years of conditioning from working with SQL databases and mapping systems have encouraged us to strongly type the fields in our data. While Triplicate will not outright reject data that isn't of a specific type, it will attempt to coerce it into that type.
	
	doctest: fields with coercion
	>> class Document
			include Triplicate
			field :body, :coerce => String
			field :rating, :coerce => Fixnum
			field :score, :coerce => Integer
			field :rank, :coerce => Float
			end
	>> doc = Document.new

	>> doc[:body] = 3
	>> doc.document["body"]
	=> "3"
	
	>> doc[:rating] = "4.13"
	>> doc.document["rating"]
	=> 4
	
	>> doc[:score] = "5.6"
	>> doc.document["score"]
	=> 5
	
	>> doc[:rank] = "99.9"
	>> doc.document["rank"]
	=> 99.9
	
Booleans are handled by declaring the coercion to be `TrueClass` or `FalseClass`. The field will be set by the truthiness of the value, however truthiness is determined by Javascript rules, not Ruby rules. In addition to `nil` and `false`, blank Strings, zero-value Numerics or numeric-like Strings, empty Arrays or Arrays containing a single value of the previous descriptions are all falsy:
	
	>> Document.field :boolean, :coerce => TrueClass
	>> doc[:boolean] = "foo"
	>> doc.document['boolean']
	=> true
	>> falsy = [nil, false, [], [[]], [[[]]], [[[[[[[[[[[[[[]]]]]]]]]]]]]],
				'', ' ', "   \n   ", "\t  ", [''], [[' ']], [[["  \n\r  "]]],
				'0', '0.0', '  00.00000 ', "\n\r0.00\t\n\r", ['0'], ['0.0'], 
				0, 0.0, [0], [[0.0]], [nil], [false]
				]
	>> falsy.all? do |val|
			doc[:boolean] = val
			doc.document['boolean'] == false
			end
	=> true
	
Time and Range are two classes whose data types don't exist in JSON and there are no real standards for converting them to JSON. These are handled specially; Time will handle any value that Time.parse will read; I recommend ISO8601 because it is human-readable and sorts lexicographically, for easy use as keys in for example CouchDB map/reduce indexes.

	>> Document.field :published_at, :coerce => Time
	>> now = Time.now
	>> doc[:published_at] = now.iso8601
	>> doc.document["published_at"].to_i == now.to_i
	=> true
	
	>> Document.field :range, :coerce => Range
	>> ranges = [(2..10), (2...10), (3.14..10), (3.14...10), (2..3.14), (2...3.14), (2.71..3.14), (2.71...3.14)]
	>> ranges.all? do |range| 
			doc[:range] = range.to_s
			doc.document["range"] == range
			end
	=> true
	
All of the above coercions require special handling, and the handling for such is provided by a series of Procs in `Triplicate::COERCIONS`, indexed by Class name. Provided no coercion is found for a particular class, Triplicate will fall back to passing the given value to the class's #new method:

	>> Triplicate::COERCIONS[Regexp]
	=> nil
	>> Regexp.new /matches\.*/i.to_s
	=> /(?i-mx:matches\.*)/
	
	>> Document.field :regexp, :coerce => Regexp
	>> doc[:regexp] = /matches\.*/i.to_s
	>> doc.document["regexp"]
	=> /(?i-mx:matches\.*)/
	
	>> require 'set'
	>> Document.field :set, :coerce => Set
	>> doc[:set] = [1,6,8]
	>> doc.document["set"]
	=> Set.new([1,6,8])
	
You can also provide custom Coercions as needed:

	>> require 'matrix'
	>> Triplicate::COERCIONS[Vector] = lambda{|v| Vector.elements(v, true) }
	>> Document.field :vector, :coerce => Vector
	>> doc[:vector] = [3,1,4]
	>> doc.document["vector"]
	=> Vector[3,1,4]

Values that are already `#kind_of?` the given class will not be coerced:

	>> class MyString < String; end
	>> doc[:body] = MyString.new("foo")
	>> doc.document['body'].class
	=> MyString

However from a loaded document, the value will be coerced into the field's given class, not the original class, unless the provided coercion does so otherwise.

Triplicate will coerce values from a loaded document into the specified types lazily when they are accessed:
	
	>> values = {
		'body' => 3,
		'rating' => '4.13',
		'score' => '5.6',
		'rank' => '99.9', 
		'published_at' => Time.local(2009, 12, 28, 1, 5, 0).iso8601,
		'range' => '2..10',
		'regexp' => "(?i-mx:matches\\.*)"
		}
	>> doc = Document.new(values)
	
	>> doc.document["body"]
	=> 3
	>> doc[:body]
	=> "3"
	>> doc.document["body"]
	=> "3"

	>> doc[:rating]
	=> 4
	
	>> doc[:score]
	=> 5

	>> doc[:rank]
	=> 99.9

	>> doc[:published_at].iso8601
	=> "2009-12-28T01:05:00-08:00"

	>> doc[:range]
	=> 2..10
	
	>> doc[:regexp]
	=> /(?i-mx:matches\.*)/

If you use JSON's "common additions" to core classes, they will parse correctly when passed in as a Hash:
	
	doctest: correctly coerces JSON-parsed hashes of core classes when JSON 'common additions' are loaded
	>> require 'json/add/core'
	>> now = Time.now
	>> Triplicate.coerce(JSON.parse(now.to_json), Time).to_i
	=> now.to_i
	>> Triplicate.coerce(JSON.parse((3..5).to_json), Range)
	=> 3..5
	>> Triplicate.coerce(JSON.parse(/regexp\.*/i.to_json), Regexp)
	=> /regexp\.*/i
	
Note that while this may be faster than parsing string values the way Triplicate does it, the json structure that json/add/core uses to represent these classes is typically not human-readable and is not easy to sort on.